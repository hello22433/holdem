"현재는 단일 서버 구조이고 빠른 개발이 목표이므로, 인프라 비용이 드는 Redis 대신 Java 고유의 모니터 락(synchronized)을 사용하여 동시성을 제어했습니다. 추후 스케일 아웃이 필요하면 Redis 분산락으로 전환할 설계를 염두에 두었습니다."


"메모리 기반의 게임 서버에서는 DB의 Rollback 기능을 사용할 수 없습니다. 따라서 Application Level Transaction을 구현했습니다.

Atomicity (원자성): 칩 차감과 팟 증가는 동시에 성공하거나, 실패하면 둘 다 실행되지 않아야 합니다. 이를 위해 try-catch 블록 내에서 예외 발생 시 이전 상태(Snapshot)로 복구하는 로직을 짰습니다.

Consistency (일관성): 플레이어 감소분 == 팟 증가분이라는 불변의 법칙(Invariant)을 코드 레벨에서 검증하여, 로직 오류로 인한 자산 증발을 원천 차단했습니다."

"실시간 게임에서는 패킷 사이즈가 곧 네트워크 비용(Latency & Bandwidth)입니다.

편리한 JSON을 사용할 경우, 매 요청마다 "playerId", "action" 같은 메타데이터가 중복 전송되는 비효율이 있었습니다.

저는 이를 해결하기 위해 ByteBuffer를 활용한 커스텀 바이너리 직렬화를 구현했습니다. 그 결과, 데이터 정합성을 유지하면서도 패킷 크기를 약 52% 절감시켰습니다. 이는 동시 접속자가 몰릴수록 서버 부하를 기하급수적으로 줄여주는 핵심 최적화입니다."